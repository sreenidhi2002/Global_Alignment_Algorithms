# -*- coding: utf-8 -*-
"""CS 466 Final Project Code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JkDSCozsD4-V_ZvMvKUE-FQjUsuRdakw
"""

import numpy as np
import matplotlib
import random
import time
import psutil
import matplotlib.pyplot as plt

"""Random Sequence Generator"""

def generate_random_sequence(length):
    nucleotides = ['A', 'T', 'C', 'G']
    random_sequence = [random.choice(nucleotides) for i in range(length)]
    return ''.join(random_sequence)
# short
a = generate_random_sequence(5)
b = generate_random_sequence(10)
c = generate_random_sequence(20)
d = generate_random_sequence(100)
e = generate_random_sequence(1000)

#long
#f = generate_random_sequence(1000000)
#g = generate_random_sequence(1500000)
h = generate_random_sequence(200000)

print("Short Sequences (5-1000 BP): ")
print(a)
print(b)
print(c)
print(d)
print(e)
print("")
print("Long Sequences (1M-2M BP): ")
print(h)

"""### Needleman-Wunsch (Baseline)"""

MATCH = 1
MISMATCH = -1
GAP = -1

def match_score(char1, char2):
    if char1 == char2:
        return MATCH
    elif char1 == '-' or char2 == '-':
        return GAP
    else:
        return MISMATCH

first_sequences = []
second_sequences = []
scores = []

def print_sequence_alignment(seq1, seq2):
    # Reverse the sequences
    seq1 = seq1[::-1]
    seq2 = seq2[::-1]

    aligned_symbol = ''
    identity = 0
    score = 0

    for aa1, aa2 in zip(seq1, seq2):
        if aa1 == aa2:
            aligned_symbol += aa1
            identity += 1
            score += match_score(aa1, aa2)
        elif aa1 != aa2 and aa1 != '-' and aa2 != '-':
            aligned_symbol += ' '
            score += match_score(aa1, aa2)
        elif aa1 == '-' or aa2 == '-':
            aligned_symbol += ' '
            score += GAP

    print(f'Score = {score}')
    print(seq1)
    # print(aligned_symbol)
    print(seq2)
    scores.append(score)
    first_sequences.append(seq1)
    second_sequences.append(seq2)

def needleman_wunsch(seq1, seq2):
    m = len(seq1)
    n = len(seq2)

    score_table = np.zeros((m + 1, n + 1))


    for i in range(0, m + 1):
        score_table[i][0] = GAP * i
    for j in range(0, n + 1):
        score_table[0][j] = GAP * j

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            matching = score_table[i - 1][j - 1] + match_score(seq1[i-1], seq2[j-1])
            delete = score_table[i - 1][j] + GAP
            insert = score_table[i][j - 1] + GAP
            score_table[i][j] = max(matching, delete, insert)

    # Traceback and compute the alignment
    align1, align2 = '', ''
    i, j = m, n  # start from the bottom right cell
    while i > 0 and j > 0:  # ending at (0,0)
        score_current = score_table[i][j]
        score_diagonal = score_table[i-1][j-1]
        score_up = score_table[i][j-1]
        score_left = score_table[i-1][j]

        if score_current == score_up + GAP:
            align1 += '-'
            align2 += seq2[j-1]
            j -= 1

        elif score_current == score_left + GAP:
            align1 += seq1[i-1]
            align2 += '-'
            i -= 1

        elif score_current == score_diagonal + match_score(seq1[i-1], seq2[j-1]):
            align1 += seq1[i-1]
            align2 += seq2[j-1]
            i -= 1
            j -= 1



    # Finish tracing up to the top left cell
    while i > 0:
        align1 += seq1[i-1]
        align2 += '-'
        i -= 1
    while j > 0:
        align1 += '-'
        align2 += seq2[j-1]
        j -= 1

    # Reverse the alignments
    align1 = align1[::-1]
    align2 = align2[::-1]
    return align1, align2
    # print_sequence_alignment(align1, align2)

seq1 = "AGTACGCA"
seq2 = "TATAGC"
a1, a2 = needleman_wunsch(seq1, seq2)
print_sequence_alignment(a1, a2)

"""# Hirschberg Algorithm"""

def get_prefix_suffix(seq1, seq2, is_prefix):
    m = len(seq1)
    n = len(seq2)
    score_table = np.zeros((m + 1, n + 1))

    for j in range(n + 1):
        score_table[0][j] = GAP * j

    for i in range(1, m + 1):
        score_table[i][0] = score_table[i - 1][0] + GAP
        for j in range(1, n + 1):
            if is_prefix:
              matching = score_table[i - 1][j - 1] + match_score(seq1[i - 1], seq2[j - 1])
            else:
              matching = score_table[i - 1][j - 1] + match_score(seq1[m - i], seq2[n - j])

            delete = score_table[i - 1][j] + GAP
            insert = score_table[i][j - 1] + GAP
            score_table[i][j] = max(matching, delete, insert)

    return score_table[m]

def hirschberg(seq1, seq2):
    alignment_score = 0
    alignment_text = ""
    m = len(seq1)
    n = len(seq2)

    # base case
    if n < 2 or m < 2:
        # In this case, we just use the N-W algorithm.
        return needleman_wunsch(seq1, seq2)
    else:
        # Make partitions
        midpoint_value = m // 2 # // is integer diviison
        F = get_prefix_suffix(seq1[:midpoint_value], seq2, is_prefix=True)
        B = get_prefix_suffix(seq1[m // 2:], seq2, is_prefix=False)

        partition = [F[j] + B[n - j] for j in range(n + 1)]
        cut = partition.index(max(partition))

        # recursive call hirschberg
        callLeft = hirschberg(seq1[:m // 2], seq2[:cut])
        callRight = hirschberg(seq1[m // 2:], seq2[cut:])

        return [callLeft[r] + callRight[r] for r in range(2)]

seq1 = "AGTACGCA"
seq2 = "TATAGC"
ah1, ah2 = hirschberg(seq1, seq2)
print_sequence_alignment(ah1, ah2)

"""# Time and Memory

"""

def find_time_and_memory(func, *args):
    start_time = time.time()
    start_memory = psutil.Process().memory_info().rss / 1024.0  # in KB

    result = func(*args)

    end_time = time.time()
    end_memory = psutil.Process().memory_info().rss / 1024.0  # in KB

    execution_time = end_time - start_time
    memory_used = end_memory - start_memory
    # memory_used = memory_usage(func,(*args))

    return result, execution_time, memory_used

# input_sizes = list(range(1000, 5000, 1000))
input_sizes = [10, 50, 100, 200, 500, 1000, 2000]

print("input_sizes",input_sizes)
alignments_nw = []
execution_times_nw = []
memory_usages_nw = []


alignments_hirschberg = []
execution_times_hirschberg = []
memory_usages_hirschberg = []

for size in input_sizes:
    seq1 = generate_random_sequence(size)
    seq2 = generate_random_sequence(size)

    result_nw, exec_time_nw, mem_usage_nw = find_time_and_memory(needleman_wunsch, seq1, seq2)
    result_hirschberg, exec_time_hirschberg, mem_usage_hirschberg = find_time_and_memory(hirschberg, seq1, seq2)

    alignments_nw.append(result_nw)
    execution_times_nw.append(exec_time_nw)
    memory_usages_nw.append(mem_usage_nw)

    alignments_hirschberg.append(result_hirschberg)
    execution_times_hirschberg.append(exec_time_hirschberg)
    memory_usages_hirschberg.append(mem_usage_hirschberg)

print("alignments_nw", alignments_nw)

print(memory_usages_nw)
print(memory_usages_hirschberg)

# Plotting
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.plot(input_sizes, execution_times_nw)
plt.title('Execution Time vs Input Size for Needleman-Wunsch')
plt.xlabel('Input Size')
plt.ylabel('Execution Time (seconds)')

plt.subplot(1, 2, 2)
plt.plot(input_sizes, memory_usages_nw)
plt.title('Memory Usage vs Input Size for Needleman-Wunsch')
plt.xlabel('Input Size')
plt.ylabel('Memory Usage (KB)')

plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.plot(input_sizes, execution_times_hirschberg)
plt.title('Execution Time vs Input Size for Hirschberg')
plt.xlabel('Input Size')
plt.ylabel('Execution Time (seconds)')

plt.subplot(1, 2, 2)
plt.plot(input_sizes, memory_usages_hirschberg)
plt.title('Memory Usage vs Input Size for Hirschberg')
plt.xlabel('Input Size')
plt.ylabel('Memory Usage (KB)')

plt.tight_layout()
plt.show()

"""# Test Cases"""

#test case 1
#short sequences

seq1 = generate_random_sequence(7)
seq2 = generate_random_sequence(5)

#needleman wunsch
aw1, aw2 = needleman_wunsch(seq1, seq2)
print("Needleman-Wunsch Implementation: ")
print_sequence_alignment(aw1, aw2)

#hirschberg
ah1, ah2 = hirschberg(seq1, seq2)
print("Hirschberg Implementation: ")
print_sequence_alignment(ah1, ah2)

#test case 2
#short sequences

seq1 = generate_random_sequence(15)
seq2 = generate_random_sequence(18)


#needleman wunsch
aw1, aw2 = needleman_wunsch(seq1, seq2)
print("Needleman-Wunsch Implementation: ")
print_sequence_alignment(aw1, aw2)

#hirschberg
ah1, ah2 = hirschberg(seq1, seq2)
print("Hirschberg Implementation: ")
print_sequence_alignment(ah1, ah2)

#test case 3
#long sequences

seq1 = generate_random_sequence(1200)
seq2 = generate_random_sequence(1500)


#needleman wunsch
aw1, aw2 = needleman_wunsch(seq1, seq2)
print("Needleman-Wunsch Implementation: ")
print_sequence_alignment(aw1, aw2)

#hirschberg
ah1, ah2 = hirschberg(seq1, seq2)
print("Hirschberg Implementation: ")
print_sequence_alignment(ah1, ah2)

#test case 4
#long sequences

seq1 = generate_random_sequence(10000)
seq2 = generate_random_sequence(10000)

#needleman wunsch
aw1, aw2 = needleman_wunsch(seq1, seq2)
print("Needleman-Wunsch Implementation: ")
print_sequence_alignment(aw1, aw2)

#hirschberg
ah1, ah2 = hirschberg(seq1, seq2)
print("Hirschberg Implementation: ")
print_sequence_alignment(ah1, ah2)